/**
   This class is a source of the electric and magnetic fields in the RF cavity. 
	 The field has axial symmetry and generated by the SuperFish code. This class
	 is a subclass of the BaseFieldSource class from OrbitUtils.
	 The class can represent several RF gaps.
*/


#include <iostream>
#include <cmath>

#include "OrbitConst.hh"
#include "SuperFishFieldSource.hh"

using namespace OrbitUtils;


// Constructor
SuperFishFieldSource::SuperFishFieldSource(): BaseFieldSource()
{
	field_phase = 0.;
	z_direction = +1;
	symm = 0;
	rf_frequency = 1.0;
  amplitude = 0.;
  time_init = 0.;
	field_center_pos = 0.;
	grid2D_Ez = new Grid2D(3,3);
	grid2D_Er = new Grid2D(3,3);
	grid2D_H  = new Grid2D(3,3);
	
	avg_ez_field = 0.;

}

// Destructor
SuperFishFieldSource::~SuperFishFieldSource()
{
	deleteGrids();
}

/** Delete all Grid2D grids. */
void SuperFishFieldSource::deleteGrids()
{
	if(grid2D_Ez->getPyWrapper() != NULL){
		Py_XDECREF(grid2D_Ez->getPyWrapper());
	} else {
		delete grid2D_Ez;
	}
	
	if(grid2D_Er->getPyWrapper() != NULL){
		Py_XDECREF(grid2D_Er->getPyWrapper());
	} else {
		delete grid2D_Er;
	}
	
	if(grid2D_H->getPyWrapper() != NULL){
		Py_XDECREF(grid2D_H->getPyWrapper());
	} else {
		delete grid2D_H;
	}	
}


/** Sets the Ez, Er, and H fields. */	
void SuperFishFieldSource::setGrid2D_Fields(Grid2D* grid2D_Ez_in,Grid2D* grid2D_Er_in,Grid2D* grid2D_H_in)
{
	deleteGrids();
	grid2D_Ez = grid2D_Ez_in;
	grid2D_Er = grid2D_Er_in;
	grid2D_H  = grid2D_H_in;
	double norm_coeff = 1.0;
	double ez_max = 0.;
	double ez = 0.;
	for(int i=0; i < grid2D_Ez->getSizeX(); i++){
		ez = fabs(grid2D_Ez->getValueOnGrid(i,0));
		if(ez_max < ez) ez_max = ez;
	}
	if(ez_max > 0.){
		norm_coeff = 1./ez_max;
	}
	for(int i=0; i < grid2D_Ez->getSizeX(); i++){
		for(int j=0; j < grid2D_Ez->getSizeY(); j++){
			grid2D_Ez->setValue(grid2D_Ez->getValueOnGrid(i,j)*norm_coeff,i,j);
		}
	}
	for(int i=0; i < grid2D_Er->getSizeX(); i++){
		for(int j=0; j < grid2D_Er->getSizeY(); j++){
			grid2D_Er->setValue(grid2D_Er->getValueOnGrid(i,j)*norm_coeff,i,j);
		}
	}	
	for(int i=0; i < grid2D_H->getSizeX(); i++){
		for(int j=0; j < grid2D_H->getSizeY(); j++){
			grid2D_H->setValue(grid2D_H->getValueOnGrid(i,j)*norm_coeff,i,j);
		}
	}
	//set the center position. It will be used only if the symmetry == 0.
	field_center_pos = (grid2D_Ez->getMaxX() + grid2D_Ez->getMinX())/2.0;
	
	//calculate the average filed
	avg_ez_field = 0.;
	for( int i = 0; i < grid2D_Ez->getSizeX(); i++){
		avg_ez_field += fabs(grid2D_Ez->getValueOnGrid(i,0));
	}
	avg_ez_field /=grid2D_Ez->getSizeX();
}	
	
/** 
  Returns components of the electric and magnetic filds.
	There are three possible cases:
	1) symm == 1 and z_direction == +1 : we have the half of the gap with z > 0, field_center_pos = 0
	2) symm == 0 and z_direction == +1 : we have the whole cavity, no transformation needed
	3) symm == 0 and z_direction == -1 : The whole cavity is reversed z = -z
	For cases 2) and 3) the field_center_pos = (grid2D_Ez->getMaxX()+grid2D_Ez->getMinX())/2.
	E in [V/m] and B in [T]
	The internal magnetic field grid2D_H is in [A/m] and should be converted to the [T].
*/
void SuperFishFieldSource::getElectricMagneticField(
	double x, double y, double z_in, double t, 
	double& E_x, double& E_y, double& E_z,
	double& B_x, double& B_y, double& B_z)
{
	E_x = 0.;	E_y = 0.;	E_z = 0.;
	B_x = 0.;	B_y = 0.;	B_z = 0.;
	
	double z,E_r,B;
	
  double x2 = x*x;
  double y2 = y*y;
	double r2 = x2+y2;
	double r = sqrt(r2);
	
	double phase = 2.0*OrbitConst::PI*rf_frequency*(t + time_init) + field_phase;
	double cos_phi = cos(phase);
	double sin_phi = sin(phase);	
	
	//=================================================
	// case 1) START : symm == 1 and z_direction == +1
	//=================================================
	if(symm == 1){
		z = z_in;
		
		double z_abs = fabs(z);
		
		if(z_abs > grid2D_Ez->getMaxX() || r > grid2D_Ez->getMaxY()){
			return;
		}
		
		E_z = amplitude*grid2D_Ez->getValue(z_abs,r)*cos_phi;
		
		if(r == 0.){
			return;
		}			
		
		E_r = amplitude*grid2D_Er->getValue(z_abs,r)*cos_phi;
		
		if(z < 0.){
			E_r = - E_r;
		}		
		
		B =  - OrbitConst::permeability*amplitude*grid2D_H->getValue(z_abs,r)*sin_phi;
		E_x = E_r*x/r;
		E_y = E_r*y/r;
		B_x = - B*y/r;
		B_y =   B*x/r;
		
		return;
	}
	//=================================================
	// case 1) STOP : symm == 1 and z_direction == +1
	//=================================================
	
	//===================================================
	//cases 2) or 3)     START
	//===================================================
	if(z_direction > 0.){
		z = z_in;
	} else {
		z = 2.*field_center_pos - z_in;
	}

	if( z_in > grid2D_Ez->getMaxX() || z_in < grid2D_Ez->getMinX() || r > grid2D_Ez->getMaxY()){
		return;
	}	
	
	E_z = z_direction*amplitude*grid2D_Ez->getValue(z,r)*cos_phi;
	
	if(r == 0.){
		return;
	}	
	
	E_r = amplitude*grid2D_Er->getValue(z,r)*cos_phi;

	B =   - z_direction*OrbitConst::permeability*amplitude*grid2D_H->getValue(z,r)*sin_phi;
	
	E_x = E_r*x/r;
	E_y = E_r*y/r;
	B_x = - B*y/r;
	B_y =   B*x/r;	
	//===================================================
	//cases 2) or 3)     STOP
	//===================================================
	
}

/** Returns the field phase. */
double SuperFishFieldSource::getPhase(){
	return field_phase;
}

/** Sets the field phase. */
void SuperFishFieldSource::setPhase(double phase){
	field_phase = phase;
}

/** Sets the field center position. */
void SuperFishFieldSource::setFieldCenterPos(double field_center_pos)
{
	this->field_center_pos = field_center_pos;
}

/** Returns the field center position. */
double SuperFishFieldSource::getFieldCenterPos()
{
	return field_center_pos;
}
	
/** Returns the field frequency. */
double SuperFishFieldSource::getFrequency(){
	return rf_frequency;
}

/** Sets the field frequency. */
void SuperFishFieldSource::setFrequency(double frequency){
	rf_frequency = frequency;
}

/** Returns the field amplitude. */
double SuperFishFieldSource::getAmplitude(){
	return amplitude;
}

/** Sets the field amplitude. */
void SuperFishFieldSource::setAmplitude(double amplitude){
	this->amplitude = amplitude;
}

/** Returns the average e_z field on the z-axis. */
double SuperFishFieldSource::getAvgField(){
	return amplitude*avg_ez_field;
}

/** Returns the length of the field. */
double SuperFishFieldSource::getLength(){
	if(symm == 1){
		return 2.0*grid2D_Ez->getMaxX();
	}
	return (grid2D_Ez->getMaxX() -  grid2D_Ez->getMinX());
}

/** Returns the field direction along the z-axis. */
int SuperFishFieldSource::getDirectionZ(){
	return z_direction;
}

/** Sets the field direction along the z-axis.  */
void SuperFishFieldSource::setDirectionZ(int z_direction){
	this->z_direction = z_direction/fabs(z_direction);
}

/** Returns the field symmetry property. */
int SuperFishFieldSource::getSymmetry(){
	return symm;
}

/** 
	   Sets the field symmetry property. If symm == 1 
		 the field is symmetric around the z=0. 
*/
void SuperFishFieldSource::setSymmetry(int symm){
	this->symm = symm;
}

/** Returns the field initial time. */
double SuperFishFieldSource::getTimeInit(){
	return time_init;
}

/** Sets the field initial time. */
void SuperFishFieldSource::setTimeInit(double time_init){
	this->time_init = time_init;
}

/** Returns the Grid2D instance with Ez field. */
Grid2D* SuperFishFieldSource::getGrid2D_Ez()
{
	return grid2D_Ez;
}

/** Returns the Grid2D instance with Er field. */
Grid2D* SuperFishFieldSource::getGrid2D_Er()
{
	return grid2D_Er;
}

/** Returns the Grid2D instance with H field. */
Grid2D* SuperFishFieldSource::getGrid2D_H()
{
	return grid2D_H;
}
