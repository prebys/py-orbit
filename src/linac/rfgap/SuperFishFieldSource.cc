/**
   This class is a source of the electric and magnetic fields in the RF cavity. 
	 The field has axial symmetry and generated by the SuperFish code. This class
	 is a subclass of the BaseFieldSource class from OrbitUtils.
	 The class can represent several RF gaps.
*/


#include <iostream>
#include <cmath>

#include "OrbitConst.hh"
#include "SuperFishFieldSource.hh"

using namespace OrbitUtils;


// Constructor
SuperFishFieldSource::SuperFishFieldSource(): BaseFieldSource()
{
	field_phase = 0.;
	z_direction = +1;
	symm = 0;
	rf_frequency = 1.0;
  amplitude = 0.;
 
	grid2D_Ez = new Grid2D(3,3);
	grid2D_Er = new Grid2D(3,3);
	grid2D_H  = new Grid2D(3,3);

}

// Destructor
SuperFishFieldSource::~SuperFishFieldSource()
{
	deleteGrids();
}

/** Delete all Grid2D grids. */
void SuperFishFieldSource::deleteGrids()
{
	if(grid2D_Ez->getPyWrapper() != NULL){
		Py_XDECREF(grid2D_Ez->getPyWrapper());
	} else {
		delete grid2D_Ez;
	}
	
	if(grid2D_Er->getPyWrapper() != NULL){
		Py_XDECREF(grid2D_Er->getPyWrapper());
	} else {
		delete grid2D_Er;
	}
	
	if(grid2D_H->getPyWrapper() != NULL){
		Py_XDECREF(grid2D_H->getPyWrapper());
	} else {
		delete grid2D_H;
	}	
}


/** Sets the Ez, Er, and H fields. */	
void SuperFishFieldSource::setGrid2D_Fields(Grid2D* grid2D_Ez_in,Grid2D* grid2D_Er_in,Grid2D* grid2D_H_in)
{
	deleteGrids();
	grid2D_Ez = grid2D_Ez_in;
	grid2D_Er = grid2D_Er_in;
	grid2D_H  = grid2D_H_in;
}	
	
/** 
  Returns components of the electric and magnetic filds.
	There are three possible cases:
	1) symm == 1 and z_direction == +1 : we have the half of the gap with z > 0, field_center_pos = 0
	2) symm == 0 and z_direction == +1 : we have the whole cavity, no transformation needed
	3) symm == 0 and z_direction == -1 : The whole cavity is reversed z = -z
	For cases 2) and 3) the field_center_pos = (grid2D_Ez->getMaxX()+grid2D_Ez->getMinX())/2.
	E in [V/m] and B in [T]
*/
void SuperFishFieldSource::getElectricMagneticField(
	double x, double y, double z_in, double t, 
	double& E_x, double& E_y, double& E_z,
	double& B_x, double& B_y, double& B_z)
{
	E_x = 0.;	E_y = 0.;	E_z = 0.;
	B_x = 0.;	B_y = 0.;	B_z = 0.;
	
	double z,E_r,B;
	
  double x2 = x*x;
  double y2 = y*y;
	double r2 = x2+y2;
	double r = sqrt(r2);
	
	double phase = 2.0*OrbitConst::PI*rf_frequency*t + field_phase;
	double cos_phi = cos(phase);
	double sin_phi = sin(phase);	
	
	//=================================================
	// case 1) START : symm == 1 and z_direction == +1
	//=================================================
	if(symm == 1){
		z = z_in;
		
		double z_abs = fabs(z);
		
		if(fabs(z) > grid2D_Ez->getMaxX() || r > grid2D_Ez->getMaxY()){
			return;
		}
		
		E_z = amplitude*grid2D_Ez->getValue(z_abs,r)*cos_phi;
		
		if(r == 0.){
			return;
		}			
		
		E_r = amplitude*grid2D_Er->getValue(z_abs,r)*cos_phi;
		
		if(z < 0){
			E_r = - E_r;
		}		
		
		B =  - OrbitConst::permeability*amplitude*grid2D_H->getValue(z_abs,r)*sin_phi;
		E_x = E_r*x/r;
		E_y = E_r*y/r;
		B_x = - B*y/r;
		B_y =   B*x/r;
		
		return;
	}
	//=================================================
	// case 1) STOP : symm == 1 and z_direction == +1
	//=================================================
	
	//===================================================
	//cases 2) or 3)     START
	//===================================================
	z = (z_in - field_center_pos)*z_direction;
	if( z > grid2D_Ez->getMaxX() || z < grid2D_Ez->getMinX() || r > grid2D_Ez->getMaxY()){
		return;
	}	
	
	E_z = z_direction*amplitude*grid2D_Ez->getValue(z,r)*cos_phi;
	
	if(r == 0.){
		return;
	}	
	
	E_r = amplitude*grid2D_Er->getValue(z,r)*cos_phi;
	
	
	B =  - z_direction*OrbitConst::permeability*amplitude*grid2D_H->getValue(z,r)*sin_phi;
	E_x = E_r*x/r;
	E_y = E_r*y/r;
	B_x = - B*y/r;
	B_y =   B*x/r;	
	//===================================================
	//cases 2) or 3)     STOP
	//===================================================
	
}

/** Returns the field phase. */
double SuperFishFieldSource::getPhase(){
	return field_phase;
}

/** Sets the field phase. */
void SuperFishFieldSource::setPhase(double phase){
	field_phase = phase;
}

/** Sets the field center position. */
void SuperFishFieldSource::setFieldCenterPos(double field_center_pos)
{
	this->field_center_pos = field_center_pos;
}

/** Returns the field center position. */
double SuperFishFieldSource::getFieldCenterPos()
{
	return field_center_pos;
}
	
/** Returns the field frequency. */
double SuperFishFieldSource::getFrequency(){
	return rf_frequency;
}

/** Sets the field frequency. */
void SuperFishFieldSource::setFrequency(double frequency){
	rf_frequency = frequency;
}

/** Returns the field amplitude. */
double SuperFishFieldSource::getAmplitude(){
	return amplitude;
}

/** Sets the field amplitude. */
void SuperFishFieldSource::setAmplitude(double amplitude){
	this->amplitude = amplitude;
}

/** Returns the field direction along the z-axis. */
int SuperFishFieldSource::getDirectionZ(){
	return z_direction;
}

/** Sets the field direction along the z-axis.  */
void SuperFishFieldSource::setDirectionZ(int z_direction){
	this->z_direction = z_direction;
}

/** Returns the field symmetry property. */
int SuperFishFieldSource::getSymmetry(){
	return symm;
}

/** 
	   Sets the field symmetry property. If symm == 1 
		 the field is symmetric around the z=0. 
*/
void SuperFishFieldSource::setSymmetry(int symm){
	this->symm = symm;
}

/** Returns the Grid2D instance with Ez field. */
Grid2D* SuperFishFieldSource::getGrid2D_Ez()
{
	return grid2D_Ez;
}

/** Returns the Grid2D instance with Er field. */
Grid2D* SuperFishFieldSource::getGrid2D_Er()
{
	return grid2D_Er;
}

/** Returns the Grid2D instance with H field. */
Grid2D* SuperFishFieldSource::getGrid2D_H()
{
	return grid2D_H;
}
